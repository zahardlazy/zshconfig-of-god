
# If you come from bash you might have to change your $PATH.
# export PATH=$HOME/bin:$HOME/.local/bin:/usr/local/bin:$PATH

# Path to your Oh My Zsh installation.
export ZSH="$HOME/.oh-my-zsh"

# Set name of the theme to load --- if set to "random", it will
# load a random theme each time Oh My Zsh is loaded, in which case,
# to know which specific one was loaded, run: echo $RANDOM_THEME
# See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes
ZSH_THEME="robbyrussell"

# Set list of themes to pick from when loading at random
# Setting this variable when ZSH_THEME=random will cause zsh to load
# a theme from this variable instead of looking in $ZSH/themes/
# If set to an empty array, this variable will have no effect.
# ZSH_THEME_RANDOM_CANDIDATES=( "robbyrussell" "agnoster" )

# Uncomment the following line to use case-sensitive completion.
# CASE_SENSITIVE="true"

# Uncomment the following line to use hyphen-insensitive completion.
# Case-sensitive completion must be off. _ and - will be interchangeable.
# HYPHEN_INSENSITIVE="true"

# Uncomment one of the following lines to change the auto-update behavior
# zstyle ':omz:update' mode disabled  # disable automatic updates
# zstyle ':omz:update' mode auto      # update automatically without asking
# zstyle ':omz:update' mode reminder  # just remind me to update when it's time

# Uncomment the following line to change how often to auto-update (in days).
# zstyle ':omz:update' frequency 13

# Uncomment the following line if pasting URLs and other text is messed up.
# DISABLE_MAGIC_FUNCTIONS="true"

# Uncomment the following line to disable colors in ls.
# DISABLE_LS_COLORS="true"

# Uncomment the following line to disable auto-setting terminal title.
# DISABLE_AUTO_TITLE="true"

# Uncomment the following line to enable command auto-correction.
# ENABLE_CORRECTION="true"

# Uncomment the following line to display red dots whilst waiting for completion.
# You can also set it to another string to have that shown instead of the default red dots.
# e.g. COMPLETION_WAITING_DOTS="%F{yellow}waiting...%f"
# Caution: this setting can cause issues with multiline prompts in zsh < 5.7.1 (see #5765)
# COMPLETION_WAITING_DOTS="true"

# Uncomment the following line if you want to disable marking untracked files
# under VCS as dirty. This makes repository status check for large repositories
# much, much faster.
# DISABLE_UNTRACKED_FILES_DIRTY="true"

# Uncomment the following line if you want to change the command execution time
# stamp shown in the history command output.
# You can set one of the optional three formats:
# "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"
# or set a custom format using the strftime function format specifications,
# see 'man strftime' for details.
# HIST_STAMPS="mm/dd/yyyy"

# Would you like to use another custom folder than $ZSH/custom?
# ZSH_CUSTOM=/path/to/new-custom-folder

# Which plugins would you like to load?
# Standard plugins can be found in $ZSH/plugins/
# Custom plugins may be added to $ZSH_CUSTOM/plugins/
# Example format: plugins=(rails git textmate ruby lighthouse)
# Add wisely, as too many plugins slow down shell startup.
plugins=(git)

source $ZSH/oh-my-zsh.sh

# User configuration

# export MANPATH="/usr/local/man:$MANPATH"

# You may need to manually set your language environment
# export LANG=en_US.UTF-8

# Preferred editor for local and remote sessions
# if [[ -n $SSH_CONNECTION ]]; then
#   export EDITOR='vim'
# else
#   export EDITOR='nvim'
# fi

# Compilation flags
# export ARCHFLAGS="-arch $(uname -m)"

# Set personal aliases, overriding those provided by Oh My Zsh libs,
# plugins, and themes. Aliases can be placed here, though Oh My Zsh
# users are encouraged to define aliases within a top-level file in
# the $ZSH_CUSTOM folder, with .zsh extension. Examples:
# - $ZSH_CUSTOM/aliases.zsh
# - $ZSH_CUSTOM/macos.zsh
# For a full list of active aliases, run `alias`.
#
# Example aliases
# alias zshconfig="mate ~/.zshrc"
# alias ohmyzsh="mate ~/.oh-my-zsh"
alias c="clear;neofetch --disable cpu gpu memory uptime de resolution wm de gtk theme icons host model shell battery locale font song disk packages --image_size 200px --sixel ~/Pictures/NGU1.png"
alias s="sudo"
alias zcfg="code ~/.zshrc"
alias scfg="source ~/.zshrc "

eval "$(oh-my-posh init zsh --config ~/.oh-my-posh/themes/lambdageneration.omp.json)"
alias ifconfig='sudo ifconfig'
alias .='cd .'
alias ..='cd ..'
alias ...='cd ../../'
alias ....='cd ../../../'
alias .....='cd ../../../../'
alias l='ls -lart --block-size=M'
alias h='history'
alias autoremove='sudo apt-get autoremove -y'
alias autoclean='sudo apt-get autoclean -y'
alias root='sudo -i'
alias diff='colordiff'
alias qvenv='python3 -m venv venv && source venv/bin/activate'
alias webup='sudo python -m http.server 80'
alias httpup='sudo ~/apps/up-http-tool/up'
alias ftpup='sudo python -m pyftpdlib -p 21'
alias smbup='sudo python3 /usr/share/doc/python3-impacket/examples/smbserver.py -smb2support share $(pwd)'
alias vpn-htb='sudo openvpn --config /home/crystal/Documents/HTB.ovpn'
alias vpn-academy='sudo openvpn --config /home/crystal/Documents/HTB-Academy.ovpn'
alias vpn-release_arena='sudo openvpn --config /home/crystal/Documents/HTB-Release-Arena.ovpn'
alias vpn-starting_point='sudo openvpn --config /home/crystal/Documents/HTB-Starting-Point.ovpn'
alias vpn-thm='sudo openvpn --data-ciphers "AES-256-GCM:AES-128-GCM:CHACHA20-POLY1305:AES-256-CBC" --config /home/crystal/Documents/THM.ovpn'
alias nse='ls /usr/share/nmap/scripts | grep'
alias nse-help='nmap --script-help'
alias nasm_shell='/usr/share/metasploit-framework/tools/exploit/nasm_shell.rb'
alias msfelfscan='/usr/share/framework2/msfelfscan'
alias aslr_off='echo 0 | sudo tee /proc/sys/kernel/randomize_va_space'
alias gcc_no_protections='gcc -fno-stack-protector -z execstack -no-pie'
alias dvwa_start='sudo service mysql start && sudo service apache2 start'
alias docker_fix='sudo mkdir /sys/fs/cgroup/systemd; sudo mount -t cgroup -o none,name=systemd cgroup /sys/fs/cgroup/systemd'
alias pipz_upgrade='pip freeze > requirements.txt; pip install -r requirements.txt --break --upgrade; rm requirements.txt;'
alias gemz_upgrade='sudo gem update; sudo gem clean'
alias username-anarchy='ruby ~/apps/username-anarchy/username-anarchy'
alias jwt_tool='python ~/apps/jwt_tool/jwt_tool.py'
alias wes-ng='python ~/Desktop/scripts/windows/wesng/wes.py'
alias android_studio='~/apps/android-studio/bin/studio.sh'
alias ctfd_download='python ~/ctf/helpers/ctfd_download_python/download.py'
alias enum4linux='python Desktop/scripts/enum4linux-ng/enum4linux-ng.py'
alias subbrute='python ~/apps/subbrute/subbrute.py'
alias codemerx='~/apps/codemerx/bin/CodemerxDecompile'
alias xs-strike='python ~/apps/XSStrike/xsstrike.py'
alias eyewitness='python ~/apps/EyeWitness/Python/EyeWitness.py'
alias wordlist_dl='sudo python ~/apps/wordlistctl/wordlistctl.py'
alias tplmap='python ~/apps/tplmap/tplmap.py'

installz(){ sudo apt-get install -y "$1"; }
pipz(){ pip install "$1" --break-system-packages; }

ss(){ searchsploit "$@"; }
ssx(){ searchsploit -x "$1"; }
ssm(){ searchsploit -m "$1"; }

gobusterz(){ gobuster dir -w /usr/share/dirbuster/wordlists/directory-list-lowercase-2.3-medium.txt -u "$1"; }
mscanz(){ sudo masscan -p1-65535,U:1-65535 "$1" --rate=1000 -e tun0 --wait 5 > mscan.txt; }
qmapz(){ sudo nmap -sV -sC "$1"; }

pattern_create(){ /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l "$1"; }
pattern_offset(){ /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q "$1"; }

mount(){
  if [ $# -eq 0 ]; then command mount | column -t; else sudo mount "$@"; fi
}

wpscanz(){ wpscan -e ap,t,u --api-token REDACTED --url "$1"; }
wpbrute(){ wpscan --password-attack xmlrpc -U "$2" -P "$3" --api-token REDACTED --url "$1"; }

mobsf_emulator(){ emulator -avd "$1" -writable-system -no-snapshot; }
webdavup(){ sudo wsgidav --host="$1" --port="$2" --root=/tmp --auth=anonymous; }

pchainz(){ proxychains4 -q bash; }
urlencode(){ python3 -c "from pwn import *; print(urlencode('$1'))"; }
urldecode(){ python3 -c "from pwn import *; print(urldecode('$1'))"; }

ffuf-vhost(){ arg_count=3; if [[ $2 && $2 != -* ]]; then wordlist=$2; else wordlist='/usr/share/seclists/Discovery/DNS/subdomains-top1million-110000.txt'; arg_count=2; fi; ffuf -c -H "Host: FUZZ.$1" -u http://$1 -w $wordlist ${@: $arg_count}; }
ffuf-dir(){ arg_count=3; if [[ $2 && $2 != -* ]]; then wordlist=$2; else wordlist='/usr/share/dirbuster/wordlists/directory-list-lowercase-2.3-medium.txt'; arg_count=2; fi; ffuf -c -u $1FUZZ -w $wordlist ${@: $arg_count}; }
ffuf-req(){ arg_count=2; if [[ $1 && $1 != -* ]]; then wordlist=$1; else wordlist='/usr/share/dirbuster/wordlists/directory-list-lowercase-2.3-medium.txt'; arg_count=1; fi; ffuf -c -ic -request new.req -request-proto https -w $wordlist ${@: $arg_count}; }

plzsh(){ if [[ $1 ]]; then port=$1; else port=1337; fi; stty raw -echo; (echo 'python3 -c "import pty;pty.spawn(\"/bin/bash\")" || python -c "import pty;pty.spawn(\"/bin/bash\")"' ;echo "stty$(stty -a | awk -F ';' '{print $2 $3}' | head -n 1)"; echo reset;cat) | nc -lvnp $port && reset; }
qssh(){ sshpass -p "$2" ssh -o StrictHostKeyChecking=no "$1"@"$3" ${@: 4}; }
rdp(){ xfreerdp /u:"$1" /p:"$2" /v:"$3" /size:1440x810 /clipboard /cert-ignore ${@: 4}; }

extract(){ if [ -z "$1" ]; then echo "Usage: extract <file>"; elif [ -f "$1" ]; then case "$1" in *.tar.bz2) tar xvjf "$1";; *.tar.gz) tar xvzf "$1";; *.tar.xz) tar xvJf "$1";; *.lzma) unlzma "$1";; *.bz2) bunzip2 "$1";; *.rar) unrar x -ad "$1";; *.gz) gunzip "$1";; *.tar) tar xvf "$1";; *.tbz2) tar xvjf "$1";; *.tgz) tar xvzf "$1";; *.zip) unzip "$1";; *.Z) uncompress "$1";; *.7z) 7z x "$1";; *.xz) unxz "$1";; *.exe) cabextract "$1";; *) echo "extract: '$1' - unknown archive method";; esac; else echo "$1 - file does not exist"; fi; }
lowercase_extensions(){ for file in *.*; do ext="${file##*.}"; lower_ext=$(echo "$ext" | tr '[:upper:]' '[:lower:]'); if [[ "$ext" != "$lower_ext" ]]; then mv "$file" "${file%.*}.$lower_ext"; fi; done; }

docker_run(){ docker build -t temp-app:latest . && if [ -n "$1" ]; then docker run --rm -it -p "$1":1337 temp-app:latest; else docker run --rm -it temp-app:latest; fi; }
chpwd() { ls --color=auto; }
source /usr/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
source ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh

alias ghidra="python3 /usr/local/bin/auto_ghidra.py"
alias dcm="~/Documents"
alias pic="~/Pictures"
alias vid="~/Videos"
alias tai="~/Downloads"
# Remap keyboard interrupt to Ctrl+Q
stty -ixon       # disable XON/XOFF flow control
stty intr '^Q'   # cách 1: dùng quote
alias sec="pwn checksec"
export PATH=$HOME/.cargo/bin:$PATH
alias aslr_on="echo 2 | sudo tee /proc/sys/kernel/randomize_va_space"
export PATH="$HOME/.local/bin:$PATH"
alias tplt="rm solve.py;pwn template > exploit.py"
alias cutter="/home/zahard/Downloads/Cutter-v2.4.1-Linux-Qt5-x86_64.AppImage"
export PIP_BREAK_SYSTEM_PACKAGES=1
alias elfxtract="python3 /home/zahard/Documents/CSCV/pwnable/heapnote/heapnote/elfxtract/elfxtract/main.py"

hash -d pwnkey=~/.ssh/pwncollege

alias xmod='for f in *; do [[ -f "$f" && -x "$f" ]] || file "$f" | grep -qi "ELF" && chmod +x "$f"; done'
alias ida='/home/zahard/ida-pro-9.0/ida'
alias fixlf='find . -type f -name "*.py" -exec sed -i "s/\r$//" {} +'
alias pwninit="python3 ~/tools/pwninit-py/pwninit.py"
alias desk="~/Desktop"
alias aiproj="/home/zahard/Documents/my-ai-project/my-ai-project"
alias fixhist='mv ~/.zsh_history ~/.zsh_history_bad 2>/dev/null && strings ~/.zsh_history_bad > ~/.zsh_history && fc -R ~/.zsh_history'
neofetch --sixel ~/Pictures/NGU1.png

##### === EXTRA TERMINAL POWER (APPEND ONLY) === #####
if command -v fzf >/dev/null 2>&1; then
  if [ -f /usr/share/doc/fzf/examples/key-bindings.zsh ]; then
    source /usr/share/doc/fzf/examples/key-bindings.zsh
  fi
fi

# 2) Remap phím cho widget của fzf
if [[ $- == *i* ]]; then
  # chèn file path bằng fzf
  if typeset -f fzf-file-widget >/dev/null; then
    bindkey -r '^T' 2>/dev/null   # bỏ Ctrl-T cũ nếu có
    bindkey '^F' fzf-file-widget  # Ctrl-F -> chọn file, chèn path
  fi

  # cd vào folder chọn bằng fzf
  if typeset -f fzf-cd-widget >/dev/null; then
    bindkey '^G' fzf-cd-widget    # Ctrl-G -> chọn folder, cd vào
  fi

  # history search bằng fzf
  if typeset -f fzf-history-widget >/dev/null; then
    bindkey '^R' fzf-history-widget
  fi
fi
# 1) Zsh options / history cho sướng tay
HISTSIZE=100000
SAVEHIST=100000
HISTFILE=~/.zsh_history

setopt hist_ignore_all_dups   # bỏ bớt lệnh trùng
setopt inc_append_history     # ghi history ngay khi chạy
setopt share_history          # các shell share history với nhau
setopt autocd                 # gõ tên folder là tự cd
setopt extended_glob          # glob nâng cao

# 2) fzf keybindings (Ctrl-R, Ctrl-T, Alt-C...)
if command -v fzf >/dev/null 2>&1; then
  if [ -f /usr/share/doc/fzf/examples/key-bindings.zsh ]; then
    source /usr/share/doc/fzf/examples/key-bindings.zsh
  elif [ -f ~/.fzf.zsh ]; then
    source ~/.fzf.zsh
  fi
fi

# 3) zoxide - cd thông minh
if command -v zoxide >/dev/null 2>&1; then
  eval "$(zoxide init zsh)"
  # z <pattern> để nhảy nhanh, zi để chọn interactive
  alias cdi='zi'
fi

# 4) ls / cat / find xịn hơn nếu có cài
if command -v eza >/dev/null 2>&1; then
  alias ls='eza --group-directories-first --icons'
  alias ll='eza -lh --group-directories-first --icons'
  alias la='eza -lah --group-directories-first --icons'
fi

if command -v batcat >/dev/null 2>&1; then
  alias cat='batcat --paging=never'
elif command -v bat >/dev/null 2>&1; then
  alias cat='bat --paging=never'
fi

if command -v fdfind >/dev/null 2>&1; then
  alias fd='fdfind'
fi

# 5) QoL nhỏ nhỏ nhưng hay dùng
mkcd(){ mkdir -p "$1" && cd "$1"; }

# rerun lệnh trước đó với sudo (khi quên gõ sudo)
please() { sudo "$(fc -ln -1)"; }

# grep nhanh trong history
hgrep(){ history | grep -i "$@"; }

# xem port đang listen
alias ports='ss -tulnp'

# info IP local + public
myip() {
  # --- Định nghĩa màu cứng (256-bit Colors) ---
  # Cú pháp: \e[38;5;NUMm
  # 46  = Neon Green (Xanh lá chuẩn)
  # 51  = Neon Cyan  (Xanh lơ chuẩn)
  # 196 = Red (Đỏ tươi - dùng phòng hờ)
  
  local c_pub='\e[38;5;46m'   # Ép màu Xanh Lá (cho Public)
  local c_loc='\e[38;5;51m'   # Ép màu Cyan (cho Local)
  local c_bold='\e[1m'        # In đậm
  local c_reset='\e[0m'       # Reset

  # --- 1. Xử lý Local IP ---
  local loc_ip
  if command -v ip >/dev/null 2>&1; then
    loc_ip=$(ip -4 addr show dev eth0 2>/dev/null | awk '/inet /{print $2}' | cut -d/ -f1)
  elif command -v ifconfig >/dev/null 2>&1; then
    loc_ip=$(ifconfig eth0 2>/dev/null | awk '/inet /{print $2}' | head -n1)
  else
    loc_ip="Not found"
  fi

  # --- 2. Xử lý Public IP ---
  local pub_ip
  pub_ip=$(
    curl -s --connect-timeout 2 https://ipinfo.io/ip 2>/dev/null \
    || curl -s --connect-timeout 2 https://ifconfig.me 2>/dev/null \
    || echo "(offline?)"
  )

  # --- 3. In ra màn hình ---
  # Local màu Cyan (51), Public màu Green (46)
  printf "${c_bold}%-7s${c_reset} : ${c_loc}%s${c_reset}\n"  "Local"  "$loc_ip"
  printf "${c_bold}%-7s${c_reset} : ${c_pub}%s${c_reset}\n"  "Public" "$pub_ip"
}

# 6) CTF helpers

# tạo nhanh skeleton project CTF
cproj(){
  if [ -z "$1" ]; then
    echo "Usage: cproj <ten_project>"
    return 1
  fi
  base="$HOME/ctf/$1"
  mkdir -p "$base"/{bin,src,scripts,notes,loot}
  cd "$base"
  [ ! -f notes/README.md ] && echo "# $1" > notes/README.md
}

# wrapper gdb cho pwn (chỉnh thêm nếu m dùng pwndbg/gef riêng)
gdbpwn(){
  if [ $# -eq 0 ]; then
    echo "Usage: gdbpwn <binary> [args...]"
    return 1
  fi
  gdb -q "$@"
}
if command -v fzf >/dev/null 2>&1; then
  if [ -f /usr/share/doc/fzf/examples/key-bindings.zsh ]; then
    source /usr/share/doc/fzf/examples/key-bindings.zsh
  elif [ -f ~/.fzf.zsh ]; then
    source ~/.fzf.zsh
  fi
fi

##### === BINARY QUICK INFO (OFFSETS & LIBC) – SHORT HEX & POP RDI === #####
bininfo() {
  if [ -z "$1" ]; then
    echo "Usage: bininfo <binary>"
    return 1
  fi

  local b="$1"

  if [ ! -f "$b" ]; then
    echo "bininfo: '$b' not found"
    return 1
  fi

  # màu
  local C_RESET=$'\e[0m'
  local C_HDR=$'\e[1;36m'    # bold cyan
  local C_NAME=$'\e[1;35m'   # bold magenta
  local C_OK=$'\e[1;32m'     # bold green  (libc offsets, libc path)
  local C_WARN=$'\e[1;33m'   # bold yellow
  local C_VAL=$'\e[1;34m'    # bold blue   (binary offsets)

  # helper: nhận "0000000000058750" hoặc "0x0000000000058750" -> trả "58750"
  _hex_short() {
    local v="$1"
    [[ $v == 0x* || $v == 0X* ]] || v="0x$v"
    # printf %x tự bỏ leading zero
    printf '%x' "$v"
  }

  printf '%s== file ==%s\n' "$C_HDR" "$C_RESET"
  file "$b"

  echo
  printf '%s== checksec ==%s\n' "$C_HDR" "$C_RESET"
  if command -v pwn >/dev/null 2>&1; then
    pwn checksec "$b"
  elif command -v checksec >/dev/null 2>&1; then
    checksec --file="$b"
  else
    printf '  %schecksec / pwn checksec not found.%s\n' "$C_WARN" "$C_RESET"
  fi

  echo
  printf '%s== ldd ==%s\n' "$C_HDR" "$C_RESET"
  if command -v ldd >/dev/null 2>&1; then
    ldd "$b" 2>/dev/null || printf '  %sstatic or ldd failed%s\n' "$C_WARN" "$C_RESET"
  else
    printf '  %sldd not found.%s\n' "$C_WARN" "$C_RESET"
  fi

  echo
  printf '%s== binary symbol offsets (system, "/bin/sh", pop rdi; ret) ==%s\n' "$C_HDR" "$C_RESET"

  # system@binary
  if command -v nm >/dev/null 2>&1; then
    local sys_bin
    sys_bin=$(nm -D --defined-only "$b" 2>/dev/null | awk '$3=="system"{print $1; exit}')
    if [ -n "$sys_bin" ]; then
      printf '  %ssystem@binary:%s %s0x%s%s\n' \
        "$C_NAME" "$C_RESET" "$C_VAL" "$(_hex_short "$sys_bin")" "$C_RESET"
    else
      printf '  %ssystem@binary:%s %s<not found>%s\n' \
        "$C_NAME" "$C_RESET" "$C_WARN" "$C_RESET"
    fi
  else
    printf '  %snm not found, skip system@binary.%s\n' "$C_WARN" "$C_RESET"
  fi

  # "/bin/sh"@binary
  if command -v strings >/dev/null 2>&1; then
    local shoff_bin
    shoff_bin=$(strings -a -t x "$b" 2>/dev/null | grep "/bin/sh" | head -n1 | awk '{print $1}')
    if [ -n "$shoff_bin" ]; then
      printf '  %s"/bin/sh"@binary:%s %s0x%s%s\n' \
        "$C_NAME" "$C_RESET" "$C_VAL" "$(_hex_short "$shoff_bin")" "$C_RESET"
    else
      printf '  %s"/bin/sh"@binary:%s %s<not found>%s\n' \
        "$C_NAME" "$C_RESET" "$C_WARN" "$C_RESET"
    fi
  else
    printf '  %sstrings not found, skip "/bin/sh" in binary.%s\n' "$C_WARN" "$C_RESET"
  fi

  # pop rdi; ret@binary
  local poprdi_bin=""
  if command -v ROPgadget >/dev/null 2>&1; then
    poprdi_bin=$(ROPgadget --binary "$b" --only "pop|ret" 2>/dev/null \
      | grep -m1 "pop rdi ; ret" \
      | awk -F' :' '{gsub(/^[[:space:]]+|[[:space:]]+$/, "", $1); print $1}')
  elif command -v ropper >/dev/null 2>&1; then
    poprdi_bin=$(ropper --file "$b" --search "pop rdi; ret" 2>/dev/null \
      | awk '/pop rdi; ret/ {print $1; exit}')
  fi

  if [ -n "$poprdi_bin" ]; then
    printf '  %spop rdi; ret@binary:%s %s0x%s%s\n' \
      "$C_NAME" "$C_RESET" "$C_VAL" "$(_hex_short "$poprdi_bin")" "$C_RESET"
  else
    printf '  %spop rdi; ret@binary:%s %s<not found or ROPgadget/ropper missing>%s\n' \
      "$C_NAME" "$C_RESET" "$C_WARN" "$C_RESET"
  fi

  echo
  printf '%s== libc analysis (if dynamically linked) ==%s\n' "$C_HDR" "$C_RESET"

  if ! command -v ldd >/dev/null 2>&1; then
    printf '  %sldd not found, skip libc.%s\n' "$C_WARN" "$C_RESET"
    return 0
  fi

  local libc
  libc=$(ldd "$b" 2>/dev/null | awk '/libc\.so/ {print $3; exit}')

  if [ -z "$libc" ] || [ ! -r "$libc" ]; then
    printf '  %slibc not found via ldd (maybe static / musl / custom).%s\n' "$C_WARN" "$C_RESET"
    return 0
  fi

  printf '  %slibc path:%s %s%s%s\n' "$C_NAME" "$C_RESET" "$C_OK" "$libc" "$C_RESET"

  echo
  printf '  %s-> libc system / "/bin/sh" / pop rdi; ret offsets:%s\n' "$C_HDR" "$C_RESET"

  # system@libc
  local sys_libc=""
  if command -v nm >/dev/null 2>&1; then
    sys_libc=$(nm -D --defined-only "$libc" 2>/dev/null \
      | awk '$3 ~ /^system(@@|@@GLIBC_.*)?$/ {print $1; exit}')
  elif command -v readelf >/dev/null 2>&1; then
    sys_libc=$(readelf -sW "$libc" 2>/dev/null \
      | awk '$8 ~ /^system(@@|@@GLIBC_.*)?$/ {print $2; exit}')
  fi

  if [ -n "$sys_libc" ]; then
    printf '     %ssystem@libc:%s %s0x%s%s\n' \
      "$C_NAME" "$C_RESET" "$C_OK" "$(_hex_short "$sys_libc")" "$C_RESET"
  else
    printf '     %ssystem@libc:%s %s<not found>%s\n' \
      "$C_NAME" "$C_RESET" "$C_WARN" "$C_RESET"
  fi

  # "/bin/sh"@libc
  if command -v strings >/dev/null 2>&1; then
    local shoff_libc
    shoff_libc=$(strings -a -t x "$libc" 2>/dev/null | grep "/bin/sh" | head -n1 | awk '{print $1}')
    if [ -n "$shoff_libc" ]; then
      printf '     %s"/bin/sh"@libc:%s %s0x%s%s\n' \
        "$C_NAME" "$C_RESET" "$C_OK" "$(_hex_short "$shoff_libc")" "$C_RESET"
    else
      printf '     %s"/bin/sh"@libc:%s %s<not found>%s\n' \
        "$C_NAME" "$C_RESET" "$C_WARN" "$C_RESET"
    fi
  else
    printf '     %sstrings not found, skip "/bin/sh" in libc.%s\n' "$C_WARN" "$C_RESET"
  fi

  # pop rdi; ret@libc
  local poprdi_libc=""
  if command -v ROPgadget >/dev/null 2>&1; then
    poprdi_libc=$(ROPgadget --binary "$libc" --only "pop|ret" 2>/dev/null \
      | grep -m1 "pop rdi ; ret" \
      | awk -F' :' '{gsub(/^[[:space:]]+|[[:space:]]+$/, "", $1); print $1}')
  elif command -v ropper >/dev/null 2>&1; then
    poprdi_libc=$(ropper --file "$libc" --search "pop rdi; ret" 2>/dev/null \
      | awk '/pop rdi; ret/ {print $1; exit}')
  fi

  if [ -n "$poprdi_libc" ]; then
    printf '     %spop rdi; ret@libc:%s %s0x%s%s\n' \
      "$C_NAME" "$C_RESET" "$C_OK" "$(_hex_short "$poprdi_libc")" "$C_RESET"
  else
    printf '     %spop rdi; ret@libc:%s %s<not found or ROPgadget/ropper missing>%s\n' \
      "$C_NAME" "$C_RESET" "$C_WARN" "$C_RESET"
  fi
}

##### === FAST FILE / STRING FINDERS === #####

# ff  -> tìm file trong thư mục hiện tại (hoặc dir chỉ định), dùng fd/find + fzf
# ff <pattern>          : tìm trong $PWD
# ff <dir> <pattern>    : tìm trong dir
ff() {
  local dir pattern
  if [ $# -eq 1 ]; then
    dir="."
    pattern="$1"
  elif [ $# -ge 2 ]; then
    dir="$1"
    shift
    pattern="$*"
  else
    echo "Usage:"
    echo "  ff <pattern>"
    echo "  ff <dir> <pattern>"
    return 1
  fi

  [ ! -d "$dir" ] && echo "ff: '$dir' không phải thư mục." && return 1

  if command -v fdfind >/dev/null 2>&1; then
    fdfind --hidden --follow --type f "$pattern" "$dir" 2>/dev/null | fzf
  elif command -v fd >/dev/null 2>&1; then
    fd --hidden --follow --type f "$pattern" "$dir" 2>/dev/null | fzf
  else
    find "$dir" -type f -iname "*${pattern}*" 2>/dev/null | fzf
  fi
}

# ffa -> "ff any" = tìm file *toàn hệ thống* bằng locate (siêu nhanh) + fzf
# ffa <pattern>
ffa() {
  if [ -z "$1" ]; then
    echo "Usage: ffa <pattern>"
    return 1
  fi
  if ! command -v locate >/dev/null 2>&1; then
    echo "ffa: 'locate' chưa cài (plocate/mlocate)."
    return 1
  fi
  locate -i "$1" 2>/dev/null | fzf
}

# fstr -> tìm string trong file, mặc định chỉ trong thư mục hiện tại
# fstr <string>          : tìm trong $PWD
# fstr <dir> <string>    : tìm trong dir
fstr() {
  local dir pattern
  if [ $# -eq 1 ]; then
    dir="."
    pattern="$1"
  elif [ $# -ge 2 ]; then
    dir="$1"
    shift
    pattern="$*"
  else
    echo "Usage:"
    echo "  fstr <string>"
    echo "  fstr <dir> <string>"
    return 1
  fi

  [ ! -d "$dir" ] && echo "fstr: '$dir' không phải thư mục." && return 1

  if command -v rg >/dev/null 2>&1; then
    # rg rất nhanh, nhưng giới hạn trong dir cho đỡ nát
    local out
    out=$(rg --line-number --no-heading --color=never "$pattern" "$dir" 2>/dev/null | fzf +m) || return 1
    local file line
    file=${out%%:*}
    line=${out#*:}
    line=${line%%:*}
    printf '%s:%s\n' "$file" "$line"
  else
    local out
    out=$(grep -Rni "$pattern" "$dir" 2>/dev/null | fzf +m) || return 1
    local file line
    file=${out%%:*}
    line=${out#*:}
    line=${line%%:*}
    printf '%s:%s\n' "$file" "$line"
  fi
}


##### === LS = EZA (DEFAULT THEME) === #####
if command -v eza >/dev/null 2>&1; then
  # ls giờ là eza
  alias ls='eza --group-directories-first --icons'

  # l, ll, la đều dựa trên ls (tức là eza)
  alias l='ls -lart'
  alias ll='ls -lh'
  alias la='ls -lah'
fi

# khi cd sang thư mục mới thì tự ls (eza) ra
chpwd() { ls; }

##### === SYSTEMCTL SHORTCUTS === #####

# alias core
alias sc='sudo systemctl'
alias scu='systemctl --user'

# status / restart / start / stop / enable+start / disable+stop
scs()    { sudo systemctl status "$@"; }
scr()    { sudo systemctl restart "$@"; }
scstart(){ sudo systemctl start "$@"; }
scstop() { sudo systemctl stop "$@"; }
scen()   { sudo systemctl enable --now "$@"; }
scdis()  { sudo systemctl disable --now "$@"; }

# list service theo pattern (cần rg, m có rồi)
scl() {
  if [ -z "$1" ]; then
    systemctl list-units --type=service
  else
    systemctl list-units --type=service | rg -i "$1"
  fi
}

# journalctl cho 1 service: cuối log / tail -f
jce() { sudo journalctl -u "$1" -e --no-pager; }
jcf() { sudo journalctl -u "$1" -f; }

##### === EZA AS DEFAULT LS (IGNORE LS_COLORS) === #####
if command -v eza >/dev/null 2>&1; then
  # Xóa alias cũ cho chắc ăn
  unalias ls ll la lt lg 2>/dev/null

  # Dùng từ khóa 'function' để tránh bị lỗi "defining function based on alias"
  function ls {
    (unset LS_COLORS EZA_COLORS; eza --group-directories-first --icons "$@")
  }

  function ll {
    (unset LS_COLORS EZA_COLORS; eza -lh --group-directories-first --icons "$@")
  }

  function la {
    (unset LS_COLORS EZA_COLORS; eza -lah --group-directories-first --icons "$@")
  }

  function lt {
    (unset LS_COLORS EZA_COLORS; eza -T -L 2 --group-directories-first --icons "$@")
  }

  function lg {
    (unset LS_COLORS EZA_COLORS; eza -lh --git --group-directories-first --icons "$@")
  }
fi

alias thunar='thunar &' 
# --- Auto Shimeji 978 (Chỉ chạy 1 lần duy nhất) ---
shimeji() {
    # Chạy Shijima-Qt chính
    ./Shijima-Qt/shijima-qt & sleep 0.5
    
    # Spawn các nhân vật
    ./Shijima-Qt/shijima-qt spawn --name 978 & sleep 0.1
    ./Shijima-Qt/shijima-qt spawn --name 494 & sleep 0.1
    ./Shijima-Qt/shijima-qt spawn --name "Blue Poison" & sleep 0.1
    ./Shijima-Qt/shijima-qt spawn --name Lappland & sleep 0.1
    ./Shijima-Qt/shijima-qt spawn --name Shining 
    
    # Clear màn hình và focus lại vào terminal
    c  # Lệnh clear từ config của bạn
    wmctrl -a "Konsole"
}

# Hàm Search File với Preview Code (Yêu cầu: fzf, bat)
ff() {
  fzf --preview 'bat --style=numbers --color=always --line-range :500 {}' \
      --preview-window=right:60%
}
# Check RAM & Top Processes (Clean Version)
ramz() {
  echo -e "\n\e[1;32m=== RAM USAGE ===\e[0m"
  free -h
  echo -e "\n\e[1;31m=== TOP 10 RAM EATERS ===\e[0m"
  # -eo: Tùy chỉnh cột hiển thị
  # comm: Chỉ hiện tên app (vd: code, gnome-shell) thay vì full đường dẫn
  ps -eo pid,%mem,%cpu,comm --sort=-%mem | head -n 11
}

sshup() {
    # 1. Lấy IP của máy Kali (Lấy IP đầu tiên tìm thấy)
    local ip=$(hostname -I | awk '{print $1}')
    
    # 2. Tạo chuỗi lệnh SSH
    local ssh_cmd="ssh zahard@$ip"
    
    # 3. In ra màn hình để nhìn cho sướng
    echo -e "\n\e[1;36m----------------------------------------\e[0m"
    echo -e "\e[1;32m[+] SSH Connect Command:\e[0m"
    echo -e "    $ssh_cmd"
    echo -e "\e[1;36m----------------------------------------\e[0m"
    
    # 4. MAGIC: Gửi lệnh copy OSC 52 về Tabby (Windows)
    # Nguyên lý: Mã hóa base64 chuỗi lệnh -> Gửi qua luồng hiển thị -> Tabby bắt được và nhét vào Clipboard
    printf "\033]52;c;$(echo -n "$ssh_cmd" | base64 | tr -d '\n')\a"
    
    echo -e "\e[1;33m[✔] Auto-copied to Windows Clipboard! Paste it anywhere.\e[0m\n"
}

sshup() {
    # 1. Lấy IP của máy Kali (Lấy IP đầu tiên tìm thấy)
    local ip=$(hostname -I | awk '{print $1}')
    
    # 2. Tạo chuỗi lệnh SSH
    local ssh_cmd="zahard@$ip"
    
    # 3. In ra màn hình để nhìn cho sướng
    echo -e "\n\e[1;36m----------------------------------------\e[0m"
    echo -e "\e[1;32m[+] SSH Connect Command:\e[0m"
    echo -e "    $ssh_cmd"
    echo -e "\e[1;36m----------------------------------------\e[0m"
    
    # 4. MAGIC: Gửi lệnh copy OSC 52 về Tabby (Windows)
    # Nguyên lý: Mã hóa base64 chuỗi lệnh -> Gửi qua luồng hiển thị -> Tabby bắt được và nhét vào Clipboard
    printf "\033]52;c;$(echo -n "$ssh_cmd" | base64 | tr -d '\n')\a"
    
    echo -e "\e[1;33m[✔] Auto-copied to Windows Clipboard! Paste it anywhere.\e[0m\n"
}
# --- SSH 2FA TOGGLE ---

ssh2fa_on() {
  echo -e "\e[1;33m[*] Enabling Google Authenticator 2FA...\e[0m"
  # 1. Bật module trong PAM (Xóa dấu # ở đầu dòng nếu có)
  sudo sed -i 's/^#\s*auth required pam_google_authenticator.so/auth required pam_google_authenticator.so/' /etc/pam.d/sshd
  
  # 2. Bật Interactive Mode trong SSH Config
  sudo sed -i 's/^#\?KbdInteractiveAuthentication.*/KbdInteractiveAuthentication yes/' /etc/ssh/sshd_config
  sudo sed -i 's/^#\?ChallengeResponseAuthentication.*/ChallengeResponseAuthentication yes/' /etc/ssh/sshd_config
  
  # 3. Tắt Password thường (Để tránh xung đột)
  sudo sed -i 's/^#\?PasswordAuthentication.*/PasswordAuthentication no/' /etc/ssh/sshd_config
  
  # 4. Restart và báo cáo
  sudo systemctl restart ssh
  echo -e "\e[1;32m[✔] 2FA is NOW ON. (Mode: Interactive)\e[0m"
}

ssh2fa_off() {
  echo -e "\e[1;33m[*] Disabling 2FA (Reverting to Password)...\e[0m"
  # 1. Vô hiệu hóa module trong PAM (Thêm dấu # vào đầu dòng)
  sudo sed -i 's/^auth required pam_google_authenticator.so/# auth required pam_google_authenticator.so/' /etc/pam.d/sshd
  
  # 2. Tắt Interactive Mode
  sudo sed -i 's/^#\?KbdInteractiveAuthentication.*/KbdInteractiveAuthentication no/' /etc/ssh/sshd_config
  sudo sed -i 's/^#\?ChallengeResponseAuthentication.*/ChallengeResponseAuthentication no/' /etc/ssh/sshd_config
  
  # 3. Bật lại Password thường
  sudo sed -i 's/^#\?PasswordAuthentication.*/PasswordAuthentication yes/' /etc/ssh/sshd_config
  
  # 4. Restart và báo cáo
  sudo systemctl restart ssh
  echo -e "\e[1;31m[✔] 2FA is NOW OFF. (Mode: Password Only)\e[0m"
}

# --- MATRIX MODE (TTY SWITCHING) ---

# 1. Blackmode: Bay vào TTY3 (Màn hình đen, chỉ dòng lệnh)
# Tương đương: Ctrl + Alt + F3
niggamode() {
  echo -e "\e[1;31m[*] Entering the Void...\e[0m"
  sudo chvt 3  # <--- Vẫn để sudo, nhưng nó sẽ trôi tuột qua luôn
}

godmode() {
  # ... code cũ ...
  if ! sudo chvt 2 2>/dev/null; then
      sudo chvt 1
  fi
}

